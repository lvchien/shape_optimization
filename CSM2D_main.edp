load "medit";
include "getARGV.idp"
include "operators.edp"


/* Label of borders */
int FREE = 1;                                                               // Free boundary
int SWALL = 21;                                                             // Homogeneous Dirichlet boundary of solid domain
int SLOAD = 22;                                                             // Neumann boundary of solid domain
int DUMMY = 30;                                                             // Dummy boundary


/* Constants */
real epsilon = 1e-8;

/*----------------------------------- Problem configurations -----------------------------------*/
int case = getARGV("--case", 1);                                            // Test case
real E = getARGV("--E", 21.0);                                              // The Young modulus of solid
real nus = getARGV("--nus", 0.3);                                           // The Poisson ratio of solid
real vf = getARGV("--vf", 1.) ;                                             // Volume ratio
/*----------------------------------------------------------------------------------------------*/

/*---------------------------------- Numerical configurations ----------------------------------*/                                                                
real b0 = getARGV("--b0", 1e-1);                                            // Initial value of b
real bmax = getARGV("--bmax", 1e2);                                         // Maximal value of b, no longer update if b > bmax
real l0 = getARGV("--l0", 0.0);                                             // Initial value of l
real gm = getARGV("--gm", 0.01);                                            // Regularization parameter
real tau0 = getARGV("--tau0", 1e-1);                                        // Initial descent step length
real beta = getARGV("--beta", 0.7);                                         // Update step length 
real sm = getARGV("--sm", 1e-4);                                            // Armijo condition's coefficient
real alpha = getARGV("--alpha", 1.05);                                      // Update coefficient of b: b_{n+1} = alpha*b_n
real minsgn = getARGV("--minsgn", 1e-3);                                    // Value for the stopping criterion
real minarea = getARGV("--minarea", 1e-6);                                  // Remesh parameter: remesh if any element has an area less than minarea
real mshsize = getARGV("--mshsize", 0.02);                                  // Required edge size when remeshing : hmax = mshsize, hmin = mshsize/sqrt(2)
/*--------------------------------------------------------------------------------------------*/


/*------------------------------------ IO configurations -------------------------------------*/
string smsh = getARGV("--smsh", "solid");                                   // File name of solid domain's mesh
string folder = getARGV("--folder", "results");                             // Folder containing output
int steps = getARGV("--steps", 3);                                          // Number of steps to save results once
/*--------------------------------------------------------------------------------------------*/

system("mkdir " + folder);
ofstream fout(folder + "/out.dat");

/* Save the command */
ofstream cmd(folder + "command.sh");
for (int i = 0; i < ARGV.n; i++)
    cmd << ARGV[i] << endl;
cmd.flush;

/* Load mesh */
mesh Sh = readmesh("meshes/CSM/" + smsh + ".mesh");
plot(Sh);
cout << "Done load mesh!" << endl;

/* Declare FE spaces */
fespace SUh(Sh, P1);


/* Declare FE variables */
SUh u1, u2, ua1, ua2, ut1, ut2, fs1, fs2, uload1, uload2;
SUh d1, d2, dt1, dt2;


/*-------------------------- Set initial values for each test case --------------------------*/
// TODO
if(case == 1)
{
    fs1 = 0.0; fs2 = -1.0;
    uload1 = 0.0; uload2 = 0.0;

    E = 0.1; nu = 0.005; nus = 0.05;
}
else if(case == 2)
{
    fs1 = 0.0; fs2 = 0.0;
    uload1 = 0.0; uload2 = 0.0;

    E = 15.0; nu = 0.01; nus = 0.35;
}
/*--------------------------------------------------------------------------------------------*

/* Variables */
real mu = E/(2 * (1 + nus));
real lambda = E * nus/((1 + nus) * (1 - 2 * nus));
real l = l0;
real b = b0;
real J0, vol0, convol;

/*-------------------------- Declare functions and their derivatives --------------------------*/
macro compliance() (int2d(Sh)(2.0 * mu * dot(eps2(u1, u2), eps2(u1, u2)) + lambda * div2(u1, u2) * div2(u1, u2))) //EOM
macro J() (compliance) //EOM
// TODO
macro dJ() (2.0 * (fs1 * u1 + fs2 * u2) - 2.0 * mu * dot(eps2(u1, u2), eps2(u1, u2)) - lambda * div2(u1, u2) * div2(u1, u2)) //EOM

macro vol(Th) (int2d(Th)(1.)) //EOM
macro dvol() (1.0) //EOM

macro L() (J/J0 - l * (vol(Sh) - convol)/vol0 + b/2.0 * ((vol(Sh) - convol) ^ 2)/(vol0 ^ 2)) //EOM 
macro dL() (dJ/J0 - l * dvol/vol0 + b * dvol * (vol(Sh) - convol)/(vol0 ^ 2)) //EOM
/*---------------------------------------------------------------------------------------------*/


/*-------------------------------- Declare variational problems --------------------------------*/
problem elastic2D([u1, u2], [ut1, ut2]) = 
    int2d(Sh)(2.0 * mu * dot(eps2(u1, u2), eps2(ut1, ut2)) + lambda * div2(u1, u2) * div2(ut1, ut2))
        - int2d(Sh)(fs1 * ut1 + fs2 * ut2)
        - int1d(Sh, SLOAD)(uload1 * ut1 + uload2 * ut2)
        + on(SWALL, u1 = 0.0, u2 = 0.0);

// TODO
problem solveregex1([d1, d2], [dt1, dt2]) = 
  int2d(Th)(gm * dot(Jaco2(d1, d2), Jaco2(dt1, dt2)) + dot([d1, d2], [dt1, dt2]))
       + int1d(Sh, FREE)(dL * dot([dt1, dt2], N2))
       + on(SLOAD, SWALL, FWALL, FIN, FOUT, DUMMY, d1 = 0.0, d2 = 0.0);

problem solveregex([d1, d2], [dt1, dt2]) = 
     int2d(Sh)(2 * mu * dot(eps2(d1, d2), eps2(dt1, dt2)) + lambda * div2(d1, d2) * div2(dt1, dt2))
        + int1d(Sh, FREE)(dL * dot([dt1, dt2], N2))
        + on(SLOAD, SWALL, DUMMY, d1 = 0.0, d2 = 0.0);


/*---------------------------------------- Main block -----------------------------------------*/
/* Initial values */
vol0 = vol(Sh);
convol = vol0 * vf;
elastic2D;
J0 = J;
fout << J << " " <<  L << " " << vol(Sh) - convol << " " << l0 << endl;
fout.flush;

int imax = 1000;
for(int i = 0; i < imax; i++)
{
    solveregex;
    real dd = int1d(Sh, FREE)(dL * dot([d1, d2], N2));
    cout << "Directional derivative: " << dd << endl;

    real sgn = sqrt(int1d(Sh, FREE)(d1^2 + d2^2));
    if(sgn > minsgn)
    {
        Sh = adaptmesh(Sh, hmax = mshsize, hmin = mshsize / sqrt(2), ratio = 1.5);
        plot(Sh, [d1, d2], cmm = "Iteration i = " + i + "/" + imax);

        real tau = tau0;
        real sminarea = checkmovemesh(Sh, [x + tau * d1, y + tau * d2]);

        int j = 0;
        int jmax = 40;

        while(j < jmax && !(sminarea >= minarea))
        {
            j++;
            cout << "Iteration j = " << j << "/" << jmax << ": Step length = " << tau << endl;
            tau *= beta;
            sminarea = checkmovemesh(Sh, [x + tau * d1, y + tau * d2]);
        }

        if(j < jmax)
        {
            mesh tmpSh = Sh;
            real beforeL = L;
            
            Sh = movemesh(Sh, [x + tau * d1, y + tau * d2]);
            elastic2D;
            real afterL = L;

            int k = 0;
            int kmax = 40;

            while(k < kmax && !(afterL < beforeL + sm * tau * dd))
            {
                k++;
                cout << "Iteration k = " << k << "/" << kmax << ": Step length = " << tau << endl;
                tau *= beta;
                Sh = tmpSh;

                Sh = movemesh(Sh, [x + tau * d1, y + tau * d2]);
                plot(Sh, cmm = "Iteration i = " + i + "/" + imax);
                elastic2D;
                afterL = L;
            }

            if(k < kmax)
            {
                l = l - b * (vol(Sh) - convol)/vol0;
                b = (b < bmax) ? b * alpha : bmax;
            }
            else
            {
                cout << "The shape has not been changed significant!" << endl;
                break;
            }
        }
        else
        {
            cout << "The descent direction is invalid!" << endl;
            break;
        }

        /* Save post-processing data */
        fout << J << " " <<  L << " " << vol(Sh) - convol << " " << l << endl;
        fout.flush;
        if(i % steps == 0)
        {
            savesol(folder + "/smesh." + i/steps + ".sol", Sh, [u1, u2]);
            savemesh(Sh, folder + "/smesh." + i/steps + ".mesh");
        }
    }
    else
    {
        cout << "The shape has not been changed significant!" << endl;
        break;
    }
}

/*----------------------------------------------------------------------------------------------*/

// Final results
savesol(folder + "/smesh_final.sol", Sh, [u1, u2]);
savemesh(Sh, folder + "/smesh_final.mesh");