<<<<<<< HEAD
include "operators.edp"

int DIR = 1;
int FREE = 2;
int nn = 10;
real nu = 0.05;
real epsilon = 1e-8;

border L11(t = 0.0, 1.0){x = t; y = 0.0; label = FREE;}
border L12(t = 0.0, 1.0){x = 1.0; y = t; label = FREE;}
border L13(t = 1.0, 0.0){x = t; y = 1.0; label = DIR;}
border L4(t = 1.0, 0.0){x = 0.0; y = t; label = FREE;}

border L21(t = 0.0, 0.8){x = t; y = 0.0; label = FREE;}
border L22(t = 0.0, 1.0){x = 0.8; y = t; label = FREE;}
border L23(t = 0.8, 0.0){x = t; y = 1.0; label = DIR;}

mesh Th1 = buildmesh(L11(5 * nn) + L12(5 * nn) + L13(5 * nn) + L4(5 * nn));
// mesh Th2 = buildmesh(L21(4 * nn) + L22(4 * nn) + L23(4 * nn) + L4(5 * nn));
mesh Th2 = Th1 * (x < 0.8);
plot(Th2);

fespace Vh1(Th1, P2);
fespace Ph1(Th1, P1);

fespace Vh2(Th2, P2);
fespace Ph2(Th2, P1);

Vh2 v1, v2, vt1, vt2;
Ph2 p, pt;

solve stokes2D([v1, v2, p], [vt1, vt2, pt]) = 
    int2d(Th2)(2.0 * nu * dot(eps2(v1, v2), eps2(vt1, vt2)) - p * div2(vt1, vt2) - pt * div2(v1, v2))
        - int2d(Th2)(p * pt * epsilon)
        + on(DIR, v1 = 1.0, v2 = 0.0)
        + on(FREE, v1 = 0.0, v2 = 0.0);

Vh1 u1 = v1, u2 = v2;

plot(Th1, [u1, u2]);
=======
load "medit";
include "getARGV.idp"
include "operators.edp"


/* Label of borders */
int FREE = 1;                                                               // Free boundary
int FWALL = 11;                                                             // Homogeneous Dirichlet boundary of fluid domain
int FIN = 12;                                                               // Non-homogeneous Dirichlet boundary of fluid domain
int FOUT = 13;                                                              // Neumann boundary of fluid domain
int SWALL = 21;                                                             // Homogeneous Dirichlet boundary of solid domain
int SLOAD = 22;                                                             // Neumann boundary of solid domain

/* Constants */
real epsilon = 1e-8;

/*----------------------------------- Problem configurations -----------------------------------*/
real vf = getARGV("--vf", 0.025) ;                                          // Volume fraction
real w = getARGV("--w", 1.0);                                               // Weight parameter of the objective function                                                                   
/*----------------------------------------------------------------------------------------------*/

/*---------------------------------- Numerical configurations ----------------------------------*/                                                                
real b0 = getARGV("--b0", 1e-1);                                            // Initial value of b
real bmax = getARGV("--bmax", 1e2);                                         // Maximal value of b, no longer update if b > bmax
real l0 = getARGV("--l0", 0.0);                                             // Initial value of l
real gm = getARGV("--gm", 0.01);                                            // Regularization parameter 
real tau0 = getARGV("--tau0", 1e-1);                                        // Initial descent step length
real beta = getARGV("--beta", 0.7);                                         // Update step length 
real sm = getARGV("--sm", 1e-4);                                            // Armijo condition's coefficient
real alpha = getARGV("--alpha", 1.05);                                      // Update coefficient of b: b_{n+1} = alpha*b_n
real minsgn = getARGV("--minsgn", 1e-3);                                    // Value for the stopping criterion
real minarea = getARGV("--minarea", 1e-6);                                  // Remesh parameter: remesh if any element has an area less than minarea
real mshsize = getARGV("--mshsize", 0.02);                                  // Required edge size when remeshing : hmax = mshsize, hmin = mshsize/sqrt(2)
/*--------------------------------------------------------------------------------------------*/


/*------------------------------------ IO configurations -------------------------------------*/
string folder = getARGV("--folder", "results");                             // folder contains output
int steps = getARGV("--steps", 3);                                          // number of steps to save results once
/*--------------------------------------------------------------------------------------------*/

system("mkdir " + folder);
ofstream fout(folder + "/out.dat");

/* Save the command */
ofstream cmd(folder + "/command.sh");
for (int i = 0; i < ARGV.n; i++)
    cmd << ARGV[i] << " ";
cmd << endl;
cmd.flush;

/* Build mesh */
border FW1(t = 0.0, 0.3){x = t; y = 0.0; label = FWALL;}
border F1(t = 0.0, 0.3){x = 0.3; y = t; label = FREE;}
border F2(t = 0.3, 0.7){x = t; y = 0.3; label = FREE;}
border F3(t = 0.3, 0.0){x = 0.7; y = t; label = FREE;}
border FW2(t = 0.7, 2.0){x = t; y = 0.0; label = FWALL;}
border OUT(t = 0.0, 0.5){x = 2.0; y = t; label = FOUT;}
border FW3(t = 2.0, 0.0){x = t; y = 0.5; label = FWALL;}
border IN(t = 0.5, 0.0){x = 0.0; y = t; label = FIN;}
border SW(t = 0.3, 0.7){x = t; y = 0.0; label = SWALL;}
border F4(t = 0, 2 * pi){x = 0.4 + 0.05 * cos(t); y = 0.15 + 0.05 * sin(t); label = FREE;}

mesh Fh = buildmesh(FW1(30) + F1(30) + F2(40) + F3(30) + FW2(130) + OUT(50) + FW3(200) + IN(50) + F4(50));
mesh Sh = buildmesh(SW(40) + F3(-30) + F2(-40) + F1(-30) + F4(-50));
plot(Fh, Sh);

/* Declare FE spaces */
fespace FVh(Fh, P2);
fespace FPh(Fh, P1);
fespace SUh(Sh, P1);


/* Declare FE variables */
FVh v1, v2, va1, va2, vt1, vt2, ff1, ff2, vin1, vin2, vw1, vw2, vout1, vout2;
FPh p, pa, pt, psi, psit, df1, df2, dft1, dft2;
SUh u1, u2, ua1, ua2, ut1, ut2, fs1, fs2, uload1, uload2, ds1, ds2, dst1, dst2;
func cut = (1 - (x >= 0.48) * (x <= 0.52) * (y <= 0.3)) * (1 - (y <= 0.01));


/*-------------------------- Set initial values for each test case --------------------------*/
ff1 = 0.0; ff2 = 0.0;
vin1 = 16.0 * y * (0.5 - y); vin2 = 0.0;
vout1 = 0.0; vout2 = 0.0;
fs1 = 0.0; fs2 = 0.0;
/*--------------------------------------------------------------------------------------------*

/* Variables */
real nu = 0.005;                                                            // The kinematic viscosity coefficient of fluid
real mu = 0.0476;
real lambda = 0.00529;
real l = l0;
real b = b0;
real J0, vol0, convol;


/*-------------------------- Declare functions and their derivatives --------------------------*/
macro compliance() (int2d(Sh)(2.0 * mu * dot(eps2(u1, u2), eps2(u1, u2)) + lambda * div2(u1, u2) * div2(u1, u2))) //EOM
macro dissipatedenergy() (int2d(Fh)(2.0 * nu * dot(eps2(v1, v2), eps2(v1, v2)))) //EOM
macro J() (w * compliance + (1.0 - w) * dissipatedenergy) //EOM
macro dJ() (w * (2.0 * mu * dot(eps2(u1, u2), eps2(u1, u2)) + lambda * div2(u1, u2) * div2(u1, u2))
            + 2.0 * (1 - w) * nu * dot(eps2(v1, v2), eps2(v1, v2))
            - (fs1 * ua1 + fs2 * ua2) + (ff1 * va1 + ff2 * va2)
            + 2.0 * mu * dot(eps2(u1, u2), eps2(ua1, ua2)) + lambda * div2(u1, u2) * div2(ua1, ua2)
            - 2.0 * nu * dot(eps2(v1, v2), eps2(ua1, ua2)) + p * div2(ua1, ua2)
            + 2.0 * nu * dot(eps2(v1, v2), eps2(va1, va2))) //EOM

macro vol(Th) (int2d(Th)(1.)) //EOM
macro dvol() (1.0) //EOM

macro L() (J/J0 - l * (vol(Sh) - convol)/vol0 + b/2.0 * ((vol(Sh) - convol) ^ 2)/(vol0 ^ 2)) //EOM 
macro dL() (dJ/J0 - l * dvol/vol0 + b * dvol * (vol(Sh) - convol)/(vol0 ^ 2)) //EOM
/*---------------------------------------------------------------------------------------------*/


/*-------------------------------- Declare variational problems --------------------------------*/
problem stokes2D([v1, v2, p], [vt1, vt2, pt]) = 
    int2d(Fh)(2.0 * nu * dot(eps2(v1, v2), eps2(vt1, vt2)) - p * div2(vt1, vt2) - pt * div2(v1, v2))
        - int2d(Fh)(ff1 * vt1 + ff2 * vt2)
        - int2d(Fh)(p * pt * epsilon)
        - int1d(Fh, FOUT)(vout1 * vt1 + vout2 * vt2)
        + on(FIN, v1 = vin1, v2 = vin2)
        + on(FWALL, SWALL, FREE, v1 = 0.0, v2 = 0.0);

problem elastic2D([u1, u2], [ut1, ut2]) = 
    int2d(Sh)(2.0 * mu * dot(eps2(u1, u2), eps2(ut1, ut2)) + lambda * div2(u1, u2) * div2(ut1, ut2))
        - int2d(Sh)(fs1 * ut1 + fs2 * ut2)
        - int1d(Sh, SLOAD)(uload1 * ut1 + uload2 * ut2)
        - int1d(Sh, FREE)(((2 * nu * dx(v1) - p) * N.x + nu * (dy(v1) + dx(v2)) * N.y) * ut1 + (nu * (dy(v1) + dx(v2)) * N.x + (2 * nu * dy(v2) - p) * N.y) * ut2)
        + on(SWALL, u1 = 0.0, u2 = 0.0);

problem adjointelastic2D([ua1, ua2], [ut1, ut2]) = 
    int2d(Sh)(2.0 * mu * dot(eps2(ua1, ua2), eps2(ut1, ut2)) + lambda * div2(ua1, ua2) * div2(ut1, ut2))
        + int2d(Sh)(2 * w * (2.0 * mu * dot(eps2(u1, u2), eps2(ut1, ut2)) + lambda * div2(u1, u2) * div2(ut1, ut2)))
        + on(SWALL, ua1 = 0.0, ua2 = 0.0);

problem adjointstokes2D([va1, va2, pa], [vt1, vt2, pt]) = 
    int2d(Fh)(2.0 * nu * dot(eps2(va1, va2), eps2(vt1, vt2)) - pa * div2(vt1, vt2) - pt * div2(va1, va2))
        + int2d(Fh)(4.0 * (1 - w) * nu * dot(eps2(v1, v2), eps2(vt1, vt2)))
        - int2d(Fh)(pa * pt * epsilon)
        + on(FWALL, SWALL, FIN, va1 = 0.0, va2 = 0.0)
        + on(FREE, va1 = ua1, va2 = ua2);

problem solidelliptic2D([ds1, ds2], [dst1, dst2]) = 
    int2d(Sh)(gm * dot(Jaco2(ds1, ds2), Jaco2(dst1, dst2)))
        + int2d(Sh)(dot([ds1, ds2], [dst1, dst2]))
        + int1d(Sh, FREE)((1 - gm) * (dot(tgrad2(ds1), tgrad2(dst1)) + dot(tgrad2(ds2), tgrad2(dst2))))
        + int1d(Sh, FREE)(dL * dot([dst1, dst2], N2))
        + on(SWALL, ds1 = 0.0, ds2 = 0.0);

problem fluidelliptic2D([df1, df2], [dft1, dft2]) = 
    int2d(Fh)(gm * dot(Jaco2(df1, df2), Jaco2(dft1, dft2)))
        + int2d(Fh)(dot([df1, df2], [dft1, dft2]))
        + int1d(Fh, FREE)((1 - gm) * (dot(tgrad2(df1), tgrad2(dft1)) + dot(tgrad2(df2), tgrad2(dft2))))
        + on(FREE, df1 = ds1, df2 = ds2)
        + on(FIN, FWALL, FOUT, SWALL, df1 = 0.0, df2 = 0.0);

problem streamlines(psi, psit) =
int2d(Fh)(dx(psi) * dx(psit) + dy(psi) * dy(psit))
    + int2d(Fh)(-psit * (dy(v1) - dx(v2)))
    + on(FIN, FWALL, FOUT, FREE, SWALL, psi = 0);


macro solvestate()
{
    stokes2D;
    elastic2D;
} //EOM

macro solveadjoint()
{
    adjointelastic2D;
    adjointstokes2D;
} //EOM

macro solveregex()
{
    solidelliptic2D;
    ds1 = ds1 * cut; ds2 = ds2 * cut;
    fluidelliptic2D;
} //EOM

/*----------------------------------------------------------------------------------------------*/

/*----------------------------------------- Main block -----------------------------------------*/
/* Initial values */
solvestate;
plot(Fh, Sh, [v1, v2], [u1, u2]);                                                               // TODO
J0 = J;
vol0 = vol(Sh);
convol = (vol(Sh) + vol(Fh)) * vf;
fout << J0 << " " <<  L << " " << vol(Sh) << " " << l0 << " " << b0 << endl;

int i = 0;
int imax = 1000;
real sgn = minsgn + epsilon;

while(i < imax && sgn > minsgn)
{
    i++;
    solveadjoint;
    solveregex;
    sgn = sqrt(int1d(Sh, FREE)(ds1^2 + ds2^2));
    
    Fh = adaptmesh(Fh, hmax = mshsize, hmin = mshsize / sqrt(2), ratio = 1.5);
    Sh = adaptmesh(Sh, hmax = mshsize, hmin = mshsize / sqrt(2), ratio = 1.5);
    // TSh = adaptmesh(TSh, hmax = mshsize, hmin = 1e-4, ratio = 1.5);
    plot(Fh, Sh, [df1, df2], [ds1, ds2], cmm = "Iteration i = " + i + "/" + imax);

    real tau = tau0;
    real fminarea = checkmovemesh(Fh, [x + tau * df1, y + tau * df2]);
    real sminarea = checkmovemesh(Sh, [x + tau * ds1, y + tau * ds2]);

    int j = 0;
    int jmax = 30;

    while(j < jmax && !(fminarea >= minarea && sminarea >= minarea))
    {
        j++;
        cout << "Iteration j = " << j << "/" << jmax << ": Step length = " << tau << endl;
        tau *= beta;
        fminarea = checkmovemesh(Fh, [x + tau * df1, y + tau * df2]);
        sminarea = checkmovemesh(Sh, [x + tau * ds1, y + tau * ds2]);
    }

    if(j < jmax)
    {
        mesh tmpFh = Fh;
        mesh tmpSh = Sh;
        real beforeL = L;
        
        Fh = movemesh(Fh, [x + tau * df1, y + tau * df2]);
        Sh = movemesh(Sh, [x + tau * ds1, y + tau * ds2]);
        // TSh = movemesh(TSh, [x + tau * tds1, y + tau * tds2]);
        solvestate;
        plot(Fh, Sh, [v1, v2], [u1, u2]);                                                       // TODO
        real afterL = L;

        int k = 0;
        int kmax = 30;

        real dd = int1d(Sh, FREE)(dL * dot([ds1, ds2], N2));
        while(k < kmax && !(afterL < beforeL + sm * tau * dd))
        {
            k++;
            cout << "Iteration k = " << k << "/" << kmax << ": Step length = " << tau << endl;
            tau *= beta;
            Fh = tmpFh;
            Sh = tmpSh;

            Fh = movemesh(Fh, [x + tau * df1, y + tau * df2]);
            Sh = movemesh(Sh, [x + tau * ds1, y + tau * ds2]);
            // TSh = movemesh(TSh, [x + tau * tds1, y + tau * tds2]);
            solvestate;
            afterL = L;
        }

        if(k < kmax)
        {
            l = l - b * (vol(Sh) - convol)/vol0;
            b = (b < bmax) ? b * alpha : bmax;
            cout << "b = " << b << endl;
        }
        else
        {
            cout << "The shape has not been changed significant!" << endl;
            break;
        }
    }
    else
    {
        cout << "The descent direction is invalid!" << endl;
        break;
    }

    /* Save post-processing data */
    fout << J << " " <<  L << " " << vol(Sh) << " " << l << " " << b << endl;
    if(i % steps == 0)
    {
        savesol(folder + "/fmesh." + j/steps + ".sol", Fh, [v1, v2]);
        savesol(folder + "/smesh." + j/steps + ".sol", Sh, [u1, u2]);
        savemesh(Fh, folder + "/fmesh." + j/steps + ".mesh");
        savemesh(Sh, folder + "/smesh." + j/steps + ".mesh");
    }
}
if(sgn < minsgn)
    cout << "The shape has not been changed significant!" << endl;

/*----------------------------------------------------------------------------------------------*/

// Final results
savesol(folder + "/fmesh_final.sol", Fh, [v1, v2]);
savesol(folder + "/smesh_final.sol", Sh, [u1, u2]);
savemesh(Fh, folder + "/fmesh_final.mesh");
savemesh(Sh, folder + "/smesh_final.mesh");
plot(Fh, Sh);
>>>>>>> 386af90e331d601224819739309a0c35f0cd1b19
