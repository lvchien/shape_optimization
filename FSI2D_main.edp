load "medit"
include "getARGV.idp"
include "operators.edp"

/* Label of borders */
int FREE = 1;
int FWALL = 11;
int FIN = 12;
int FOUT = 13;
int SWALL = 21;
int SLOAD = 22;

/* Load mesh */
string fmsh = "fluid";
string smsh = "solid";
mesh Fh = readmesh("meshes/FSI/" + fmsh + ".mesh");
mesh Sh = readmesh("meshes/FSI/" + smsh + ".mesh");

/* Declare FE spaces and variables */
fespace FVh(Fh, P2);
fespace FPh(Fh, P1);
fespace SUh(Sh, P1);

FVh v1, v2, va1, va2, vt1, vt2, ff1, ff2, vin1, vin2, vw1, vw2, vout1, vout2;
FPh p, pa, pt;
SUh u1, u2, ua1, ua2, ut1, ut2, fs1, fs2, uload1, uload2;

/* Set configuration */
real epsilon = 1e-8;
real nu = 0.01;
real E = 1.0;
real nuy = 0.3;
real mu = E/(2 * (1 + nuy));
real lambda = E * nuy/((1 + nuy) * (1 - 2 * nuy));
real w = 0.5;

int config = 1;

if(config == 1)
{
    ff1 = 0.0; ff2 = 0.0;
    vin1 = y * (0.5 - y); vin2 = 0.0;
    vout1 = 0.0; vout2 = 0.0;

    fs1 = 0.0; fs2 = 0.0;
    uload1 = 0.0; uload2 = 0.0;
}

problem stokes2D([v1, v2, p], [vt1, vt2, pt]) = 
    int2d(Fh)(2.0 * nu * dot(eps2(v1, v2), eps2(vt1, vt2)) - p * div2(vt1, vt2) - pt * div2(v1, v2))
        - int2d(Fh)(ff1 * vt1 + ff2 * vt2)
        - int2d(Fh)(p * pt * epsilon)
        - int1d(Fh, FOUT)(vout1 * vt1 + vout2 * vt2)
        + on(FIN, v1 = vin1, v2 = vin2)
        + on(FWALL, FREE, v1 = 0.0, v2 = 0.0);

problem elastic2D([u1, u2], [ut1, ut2]) = 
    int2d(Sh)(2.0 * mu * dot(eps2(u1, u2), eps2(ut1, ut2)) + lambda * div2(u1, u2) * div2(ut1, ut2))
        - int2d(Sh)(fs1 * ut1 + fs2 * ut2)
        - int1d(Sh, SLOAD)(uload1 * ut1 + uload2 * ut2)
        - int1d(Sh, FREE)(((2 * nu * dx(v1) - p) * N.x + nu * (dy(v1) + dx(v2) * N.y))* ut1 + (nu * (dy(v1) + dx(v2)) * N.x + (2 * nu * dy(v2) - p) * N.y)* ut2)
        + on(SWALL, u1 = 0.0, u2 = 0.0);

problem adjointelastic2D([ua1, ua2], [ut1, ut2]) = 
    int2d(Sh)(2.0 * mu * dot(eps2(ua1, ua2), eps2(ut1, ut2)) + lambda * div2(ua1, ua2) * div2(ut1, ut2))
        + int2d(Sh)(2 * w * (2.0 * mu * dot(eps2(u1, u2), eps2(ut1, ut2)) + lambda * div2(u1, u2) * div2(ut1, ut2)))
        + on(SWALL, ua1 = 0.0, ua2 = 0.0);

problem adjointstokes2D([va1, va2, pa], [vt1, vt2, pt]) = 
    int2d(Fh)(2.0 * nu * dot(eps2(va1, va2), eps2(vt1, vt2)) - pa * div2(vt1, vt2) - pt * div2(va1, va2))
        + int2d(Fh)(4.0 * (1 - w) * nu * dot(eps2(v1, v2), eps2(vt1, vt2)))
        - int2d(Fh)(pa * pt * epsilon)
        + on(FWALL, FIN, va1 = 0.0, va2 = 0.0)
        + on(FREE, va1 = ua1, va2 = ua2);

macro compliance() (int2d(Sh)(2.0 * mu * dot(eps2(u1, u2), eps2(u1, u2)) + lambda * div2(u1, u2) * div2(u1, u2))) //EOM
macro dissipatedenergy() (int2d(Fh)(2 * nu * dot(eps2(v1, v2), eps2(v1, v2)))) //EOM
macro J(w) (w * compliance + (1 - w) * dissipatedenergy) //EOM
macro dJ() (w * (2.0 * mu * dot(eps2(u1, u2), eps2(u1, u2)) + lambda * div2(u1, u2) * div2(u1, u2)) 
            + 2 * (1 - w) * nu * dot(eps2(v1, v2), eps(v1, v2)) 
            - (fs1 * ua1 + fs2 * ua2) + (ff1 * va1 + ff2 * va2)
            + 2.0 * mu * dot(eps2(u1, u2), eps2(ua1, ua2)) + lambda * div2(u1, u2) * div2(ua1, ua2)
            - 2.0 * nu * dot(eps2(v1, v2), eps(ua1, ua2)) + p * div2(ua1, ua2)
            + 2.0 * nu * dot(eps2(v1, v2), eps(va1, va2))) //EOM

stokes2D;
elastic2D;

adjointelastic2D;
adjointstokes2D;

cout << J(1.0) << endl;

plot(Fh, Sh, [v1, v2], [u1, u2]);
plot(Fh, Sh, [va1, va2], [ua1, ua2]);