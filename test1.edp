load "medit";
include "getARGV.idp"
include "operators.edp"

/* Constants */
real epsilon = 1e-8;

/*----------------------------------- Problem configurations -----------------------------------*/
int case = getARGV("--case", 1);                                            // Test case
real nu = getARGV("--nu", 0.05);                                            // The kinematic viscosity coefficient of fluid
real E = getARGV("--E", 21.0);                                              // The Young modulus of solid
real nus = getARGV("--nus", 0.3);                                           // The Poisson ratio of solid
real vf = getARGV("--vf", 1.) ;                                             // Volume ratio
real w = getARGV("--w", 1.0);                                               // Weight parameter of the objective functions
/*----------------------------------------------------------------------------------------------*/

/*---------------------------------- Numerical configurations ----------------------------------*/                                                                
real b0 = getARGV("--b0", 1e-1);                                            // Initial value of b
real bmax = getARGV("--bmax", 1e2);                                         // Maximal value of b, no longer update if b > bmax
real l0 = getARGV("--l0", 0.0);                                             // Initial value of l
real gm = getARGV("--gm", 0.01);                                            // Regularization parameter
real tau0 = getARGV("--tau0", 1e-1);                                        // Initial descent step length
real beta = getARGV("--beta", 0.7);                                         // Update step length 
real sm = getARGV("--sm", 1e-4);                                            // Armijo condition's coefficient
real alpha = getARGV("--alpha", 1.05);                                      // Update coefficient of b: b_{n+1} = alpha*b_n
real minsgn = getARGV("--minsgn", 1e-3);                                    // Value for the stopping criterion
real minarea = getARGV("--minarea", 1e-6);                                  // Remesh parameter: remesh if any element has an area less than minarea
real mshsize = getARGV("--mshsize", 0.02);                                  // Required edge size when remeshing : hmax = mshsize, hmin = mshsize/sqrt(2)
/*--------------------------------------------------------------------------------------------*/


/*------------------------------------ IO configurations -------------------------------------*/
string folder = getARGV("--folder", "results");                             // Folder containing output
int steps = getARGV("--steps", 3);                                          // Number of steps to save results once
int regex = getARGV("--regex", 1);                                          // Regularization-extension config
int nps = getARGV("--nps", 1);                                              // Number of meshing points
/*--------------------------------------------------------------------------------------------*/

system("mkdir " + folder);
ofstream fout(folder + "/out.dat");

/* Save the command */
ofstream cmd(folder + "command.sh");
for (int i = 0; i < ARGV.n; i++)
    cmd << ARGV[i] << endl;
cmd.flush;


/* Label of borders */
int FREE = 1;                                                               // Free boundary
int FWALL = 11;                                                             // Homogeneous Dirichlet boundary of fluid domain
int FIN = 12;                                                               // Non-homogeneous Dirichlet boundary of fluid domain
int FOUT = 13;                                                              // Neumann boundary of fluid domain
int SWALL = 21;                                                             // Homogeneous Dirichlet boundary of solid domain
int SLOAD = 22;                                                             // Neumann boundary of solid domain
int DUMMY = 30;                                                             // Dummy boundary


/* Build mesh */
border FW1(t = 0.0, 0.3){x = t; y = 0.0; label = FWALL;}
border F1(t = 0.0, 0.3){x = 0.3; y = t; label = FREE;}
border F2(t = 0.3, 0.7){x = t; y = 0.3; label = FREE;}
border F3(t = 0.3, 0.0){x = 0.7; y = t; label = FREE;}
border FW2(t = 0.7, 2.0){x = t; y = 0.0; label = FWALL;}
border OUT(t = 0.0, 0.5){x = 2.0; y = t; label = FOUT;}
border FW3(t = 2.0, 0.0){x = t; y = 0.5; label = FWALL;}
border IN(t = 0.5, 0.0){x = 0.0; y = t; label = FIN;}
border SW(t = 0.3, 0.7){x = t; y = 0.0; label = SWALL;}
border D1(t = 0, 0.01){x = 0.3; y = t; label = DUMMY;}
border D2(t = 0.3, 0.48){x = t; y = 0.01; label = DUMMY;}
border D3(t = 0.01, 0.3){x = 0.48; y = t; label = DUMMY;}
border D4(t = 0.48, 0.52){x = t; y = 0.3; label = DUMMY;}
border D5(t = 0.3, 0.01){x = 0.52; y = t; label = DUMMY;}
border D6(t = 0.52, 0.7){x = t; y = 0.01; label = DUMMY;}
border D7(t = 0.01, 0){x = 0.7; y = t; label = DUMMY;}

mesh Mh = buildmesh(FW1(30 * nps) + D1(1 * nps) + D2(18 * nps) + D3(29 * nps) + D4(4 * nps) + D5(29 * nps) + D6(18 * nps) + D7(1 * nps) 
    + FW2(130 * nps) + OUT(50 * nps) + FW3(200 * nps) + IN(50 * nps));
mesh Th = buildmesh(FW1(30 * nps) + SW(40 * nps) + FW2(130 * nps) + OUT(50 * nps) + FW3(200 * nps) + IN(50 * nps));
plot(Th);
cout << "Done build meshes!" << endl;

/* Declare FE spaces */
fespace FVh(Th, P2);
fespace FPh(Th, P1);
fespace SUh(Th, P1);
fespace Dh(Th, P1);
fespace DMh(Mh, P1);


/* Declare FE variables */
FVh v1, v2, va1, va2, vt1, vt2, ff1, ff2, vin1, vin2, vw1, vw2, vout1, vout2;
FPh p, pa, pt;
SUh u1, u2, ua1, ua2, ut1, ut2, fs1, fs2, uload1, uload2;
Dh d1, d2, X, XS, XF, XaF, XaS;
DMh dm1, dm2, dmt1, dmt2;
real weak = 1e8;

X = (x > 0.3 && y < 0.3 && x < 0.7) - (x < 0.3 || y > 0.3 || x > 0.7);
XS = (x >= 0.3 && y <= 0.3 && x <= 0.7);
XF = (x <= 0.3 || y >= 0.3 || x >= 0.7);
XaF = XF + weak * (1 - XF);          
XaS = XS + weak * (1 - XS);  

Th = adaptmesh(Th, X, hmax = 0.05);
Mh = adaptmesh(Mh, X, hmax = 0.05);
// plot(Mh);

ff1 = 0.0; ff2 = 0.0;
vin1 = 16 * y * (0.5 - y); vin2 = 0.0;
vw1 = 0.0; vw2 = 0.0;
vout1 = 0.0; vout2 = 0.0;

fs1 = 0.0; fs2 = 0.0;
uload1 = 0.0; uload2 = 0.0;

E = 0.1; nu = 0.005; nus = 0.05;

real mu = E/(2 * (1 + nus));
real lambda = E * nus/((1 + nus) * (1 - 2 * nus));
real l = l0;
real b = b0;
real J0, vol0, convol;

macro compliance() (int2d(Th)(2.0 * mu * XS * dot(eps2(u1, u2), eps2(u1, u2)) + lambda * XS * div2(u1, u2) * div2(u1, u2))) //EOM
macro dissipatedenergy() (int2d(Th)(2.0 * nu * XF * dot(eps2(v1, v2), eps2(v1, v2)))) //EOM
macro J() (w * compliance + (1 - w) * dissipatedenergy) //EOM
macro dJ() (w * (2.0 * mu * dot(eps2(u1, u2), eps2(u1, u2)) + lambda * div2(u1, u2) * div2(u1, u2))
            + 2.0 * (1 - w) * nu * dot(eps2(v1, v2), eps2(v1, v2))
            - (fs1 * ua1 + fs2 * ua2) + (ff1 * va1 + ff2 * va2)
            + 2.0 * mu * dot(eps2(u1, u2), eps2(ua1, ua2)) + lambda * div2(u1, u2) * div2(ua1, ua2)
            - 2.0 * nu * dot(eps2(v1, v2), eps2(ua1, ua2)) + p * div2(ua1, ua2)
            + 2.0 * nu * dot(eps2(v1, v2), eps2(va1, va2))) //EOM

macro vol(Th) (int2d(Th)(1.)) //EOM
macro dvol() (1.0) //EOM

macro L() (J/J0 - l * (int2d(Th)(XS) - convol)/vol0 + b/2.0 * ((int2d(Th)(XS) - convol) ^ 2)/(vol0 ^ 2)) //EOM 
macro dL() (dJ/J0 - l * dvol/vol0 + b * dvol * (int2d(Th)(XS) - convol)/(vol0 ^ 2)) //EOM


/*-------------------------------- Declare variational problems --------------------------------*/
problem stokes2D([v1, v2, p], [vt1, vt2, pt]) = 
    int2d(Th)(2.0 * nu * XaF * dot(eps2(v1, v2), eps2(vt1, vt2)) - p * div2(vt1, vt2) - pt * div2(v1, v2))
        - int2d(Th)(XaF *(ff1 * vt1 + ff2 * vt2))
        - int2d(Th)(XaF * (p * pt * epsilon))
        - int1d(Th, FOUT)(vout1 * vt1 + vout2 * vt2)
        + on(FIN, v1 = vin1, v2 = vin2)
        + on(FWALL, SWALL, v1 = 0.0, v2 = 0.0);

problem elastic2D([u1, u2], [ut1, ut2]) = 
    int2d(Th)(2.0 * mu * XaS * dot(eps2(u1, u2), eps2(ut1, ut2)) + lambda * XaS * div2(u1, u2) * div2(ut1, ut2))
        - int2d(Th)(XaS * (fs1 * ut1 + fs2 * ut2))
        - int1d(Th, SLOAD)(uload1 * ut1 + uload2 * ut2)
        - int1d(Th, FREE)(((2 * nu * dx(v1) - p) * N.x + nu * (dy(v1) + dx(v2)) * N.y) * ut1 + (nu * (dy(v1) + dx(v2)) * N.x + (2 * nu * dy(v2) - p) * N.y) * ut2)
        + on(SWALL, u1 = 0.0, u2 = 0.0);

stokes2D;
elastic2D;
plot([v1, v2]);
